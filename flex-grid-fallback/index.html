<!--
A grid of inline-block columns can have columns with explicit width and auto width columns. The space remaining after the explicit-width columns is distributed evenly between the rest of the columns. Columns have minimum width. When columns width exceed the available space, they are wrapped on a new row.
Used for fallback when Flexbox is not supported by the browser.
-->

<style>
	
	body {
		
		font-size: 16px;

	}
	
	.row {
	
		max-width: 800px;
		font-size: 0;
		margin: 0 auto;
		
	}
	
	.row > * {
		
		font-size: 16px; /* To do: replace by actual font size of column's row's parent */
		min-width: 20%; /* To do: support +33% */
		display: inline-block;
		padding: 1em 0;
		margin: 0;
		border: none;
		background: #eee;
		color: #333;

	}
	
	.col2 {
		
		width: 50%;

	}
	
	.col3 {
		
		width: 33.333%;

	}
	
	.col23 {
		
		width: 66.667%;
		
	}

	.col4 {
		
		width: 25%;

	}
	
</style>

<div class=row>
	
	<div>Auto</div>
	<div>Auto</div>
	<div class="col2">1/2</div>
	<div>Auto</div>
	<div>Auto</div>
	<div class="col23">2/3</div>
	<div>Auto</div>
	<div>Auto</div>
	<div class="col3">1/3</div>
	<div class="col23">2/3</div>
	<div>Auto</div>
	<div>Auto</div>
	<div>Auto</div>
	<div>Auto</div>
		
</div>

<br>

<div class=row>
	
	<div class="col23">2/3</div>
	<div>Auto</div>
	<div>Auto</div>
	<div class="col3">1/3</div>
	<div class="col23">2/3</div>
		
</div>

<script>
	
	// To do: polyfill for .classList, .forEach()
	
	if (!Element.prototype.matches) {
	    Element.prototype.matches = 
	        Element.prototype.matchesSelector || 
	        Element.prototype.mozMatchesSelector ||
	        Element.prototype.msMatchesSelector || 
	        Element.prototype.oMatchesSelector || 
	        Element.prototype.webkitMatchesSelector ||
	        function(s) {
	            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
	                i = matches.length;
	            while (--i >= 0 && matches.item(i) !== this) {}
	            return i > -1;            
	        };
	}

	function columnWidth(el) { // Get width in % from a .col23 etc column

		rules = document.styleSheets[0].cssRules;
		var i;
		for(i in rules) {
			if (rules[i].selectorText=== '.' + el.classList[0]) {
				return parseFloat(rules[i].cssText.split('width: ')[1].split('%')[0], 10);
			}
		}
		return false;
	}

	function flexGridFallback() {
		
		document.querySelectorAll('.row').forEach( function (row) { // All rows
		
			var start_index = 0;
			var end_index = 0;
			var i = 0;
			for (; i < row.children.length; i++) { // All columns in current row. :scope to be replaced by temporary id fallback
			
				var el = row.children[i];
				if (el.offsetLeft === row.offsetLeft)  { // If offset is the same as the row, the row has wrapped and its columns must take up 100% width

					end_index = i - 1;
					var number_auto_columns = 0;
					var space_taken = 0;
					
					var j;
					for (j = start_index; j <= end_index; j++) { // Cycle columns of the current auto-wrapped row
						
						if (row.children[j].matches('[class^=col]')) {
							
							space_taken += columnWidth(row.children[j]);
							
						} else {
							
							number_auto_columns++;
						
						}
						
					}
					
// 					console.log('Start: ' + start_index + ', End: ' + end_index + ', Number of auto columns: ' + number_auto_columns);
					
					var auto_column_width = (100 - space_taken) / number_auto_columns;
					
					for (j = start_index; j <= end_index; j++) { // Cycle columns of the current auto-wrapped row
						
						if (!row.children[j].matches('[class^=col]')) {
							
							row.children[j].style.width = auto_column_width + '%';
							
						}
						
					}

					start_index = end_index + 1;

				}

			}
			
		});
		
	}
	
	flexGridFallback();

</script>
