<!DOCTYPE html>

<!--
A grid of inline-block columns can have columns with explicit width and auto width columns. The space remaining after the explicit-width columns is distributed evenly between the rest of the columns. Columns have minimum width. When columns width exceed the available space, they are wrapped on a new row.
Used for fallback when Flexbox is not supported by the browser.
-->

<style>
	
	body {
		
		font-size: 16px;

	}
	
	.row {
	
		max-width: 800px;
		font-size: 0;
		margin: 0 auto;
		
	}
	
	.row > * {
		
		font-size: 16px; /* To do: replace by actual font size of column's row's parent */
		min-width: 20%; /* To do: support +33% */
		display: inline-block;
		padding: .5em;
		margin: 0;
		border: none;
		color: #333;
		box-sizing: border-box;
/* 		border: 1px solid #999; */
		vertical-align: top;
		position: relative;

	}
	
/*
	.row > *:before {
		
		content: "";
		background: #eee;
		top: .5em;
		right: .5em;
		bottom: .5em;
		left: .5em;
		position: absolute;
		z-index: -1;

	}
*/
	
/*
	.row > * > * {
		
		padding: .5em;

	}
*/
	
	.row > * {
		
		max-width: 20%;
		
	}
	
	.row > *[class^=col] {
		
		max-width: none;

	}
	
	.col2 {
		
		width: 50%;

	}
	
	.col3 {
		
		width: 33.333%;

	}
	
	.col23 {
		
		width: 66.667%;
		
	}

	.col4 {
		
		width: 25%;

	}
	
	.align-right {
		
		text-align: right;
		
	}
	
	.align-left {
		
		text-align: left;
		
	}
	
	.align-center {
		
		text-align: center;

	}
	
	.align-middle {
		
		vertical-align: middle;

	}
	
	.row.table {
		
		display: table;
		width: 100%;
		table-layout: fixed;
		border-spacing: .5em;
		border-collapse: separate;
		font-size: inherit;
		margin-bottom: -.5em;

	}

	.row.table > * {
		
		display: table-cell;
		background: #eee;
		
	}
		
	.row.table > *:before {
		
		display: none;
		
	}
		
</style>

<div class=row>
	
	<div><div>Auto Auto Auto Auto Auto Auto Auto Auto Auto Auto Auto Auto Auto Auto </div></div>
	<div class="align-right"><div>Auto<br>Right-aligned</div></div>
	<div class="col2 align-center align-middle"><div>1/2<br>Centered</div></div>
	<div><div>Auto</div></div>
	<div><div>Auto</div></div>
	<div class="col23"><div>2/3</div></div>
	<div><div>Auto</div></div>
	<div><div>Auto</div></div>
	<div class="col3"><div>1/3</div></div>
	<div class="col23"><div>2/3</div></div>
	<div><div>Auto</div></div>
	<div><div>Auto</div></div>
	<div><div>Auto</div></div>
	<div><div>Auto</div></div>
		
</div>

<br><br>

<div class=row>
	
	<div class="col23"><div>2/3</div></div>
	<div><div>Auto</div></div>
	<div><div>Auto</div></div>
	<div class="col3"><div>1/3</div></div>
	<div class="col23"><div>2/3</div></div>
		
</div>

<script>

	function selectorMatches(el, selector) {
		
		return el.className.indexOf(selector) > -1;

	}
	
	var previousElementSibling = function( el ) { // IE8 doesn't support Element.previousElementSibling natively
	    if( el.previousElementSibling ) {
	        return el.previousElementSibling;
	    } else {
	        while( el = el.previousSibling ) {
	            if( el.nodeType === 1 ) return el;
	        }
	    }
	}

	// To do: equal height & vertical alignment, margin & padding

	function getStyle(el,styleProp) {
		if (el.currentStyle)
			var y = el.currentStyle[styleProp];
		else if (window.getComputedStyle)
			var y = document.defaultView.getComputedStyle(el,null).getPropertyValue(styleProp);
		return y;
	
	}

	function flexGridFallback() {
		
		var rows = document.querySelectorAll('.row'); // Node list to array
		var row_index = 0;
		
		for(;row_index < rows.length; row_index++) { // All rows
			
			var row = rows.item(row_index);
		
			var start_index = 0;
			var end_index = 0;
			var i = 1;
			for (;i <= row.children.length; i++) { // All columns in current row.
				
				var el = row.children[i];
				if (i === row.children.length || el.offsetLeft === row.offsetLeft)  { // If offset is the same as the row, the row has wrapped and its columns must take up 100% width

					end_index = i - 1;
					var number_auto_columns = 0;
					var space_taken = 0;
					
					var j;
					var max_height = 0;
					for (j = start_index; j <= end_index; j++) { // Cycle columns of the current auto-wrapped row
						
						if (selectorMatches(row.children[j], 'col')) {
							
							if (getStyle(row.children[j], 'width').indexOf('px') == -1) { // IE8, returning % instead of px
	
								space_taken = parseFloat(getStyle(row.children[j], 'width'));
							
							} else {
							
								space_taken = parseFloat(getStyle(row.children[j], 'width')) / parseFloat(getStyle(row, 'width'))*100;
							
							}
							
						} else {
							
							number_auto_columns++;
						
						}
						if (row.children[j].scrollHeight > max_height) {
							
							max_height = row.children[j].scrollHeight + 'px';

						}
						
					}
					
// 					console.log('Start: ' + start_index + ', End: ' + end_index + ', Auto columns: ' + number_auto_columns);
					
					var auto_column_width = (100 - space_taken) / number_auto_columns;
					
					for (j = start_index; j <= end_index; j++) { // Cycle columns of the current auto-wrapped row
						
						if (!selectorMatches(row.children[j], 'col')) {
							
							row.children[j].style.width = auto_column_width + '%';
							row.children[j].style.maxWidth = 'none';
							
						}
						
						row.children[j].style.minHeight = max_height;
						
					}

					start_index = end_index + 1;

				}

			}
			
		}
		
	}
	
	function flexGridFallbackSplit() { // Second approach: split all wrapped rows into separate .row.table
	
		var rows = document.querySelectorAll('.row'); // Node list to array
		var row_index = 0;
		
		for(;row_index < rows.length; row_index++) { // All rows
			
			var row = rows.item(row_index);
			console.log(row);
			var start_index = new Array('0');
			var end_index = new Array('0');
			var i = 1;
			for (;i <= row.children.length; i++) { // All columns in current row.

				var el = row.children[i];
				if (i === row.children.length || el.offsetLeft === row.offsetLeft)  { // If offset is the same as the row, the row has wrapped and its columns must take up 100% width

					row.insertAdjacentHTML('beforebegin', '<div class="row table"></div>');
					end_index[end_index.length] = i - 1;

					console.log('Start: ' + start_index[start_index.length-1] + ', End: ' + end_index[end_index.length-1]);

					var j;
					for (j = start_index[start_index.length-1]; j <= end_index[end_index.length-1]; j++) { // Cycle columns of the current auto-wrapped row

// 						row.previousElementSibling.appendChild(row.children[j]);

// 						row.previousElementSibling.insertAdjacentHTML('beforeend', row.children[j].outerHTML); // To do: append the node not to lose events etc
						previousElementSibling(row).insertAdjacentHTML('beforeend', row.children[j].outerHTML); // To do: append the node not to lose events etc
						
					}
					
					start_index[start_index.length] = end_index[end_index.length-1] + 1;
		
				}
		
			}
			
			// Move elements here. Afer each element is moved, start_index and end_index should be subtracted by 1?
			console.log(start_index + '   ' + end_index);
			
			row.outerHTML = '';
			
		}

	}

// 	flexGridFallback();
	flexGridFallbackSplit();

</script>
