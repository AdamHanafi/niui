<!DOCTYPE html>

<!--
A grid of inline-block columns can have columns with explicit width and auto width columns. The space remaining after the explicit-width columns is distributed evenly between the rest of the columns. Columns have minimum width. When columns width exceed the available space, they are wrapped on a new row.
Used for fallback when Flexbox is not supported by the browser.
-->

<style>
	
	body {
		
		font-size: 16px;

	}
	
	.row {
	
		max-width: 800px;
		font-size: 0;
		margin: 0 auto;
		
	}
	
	.row > * {
		
		font-size: 16px; /* To do: replace by actual font size of column's row's parent */
		min-width: 20%; /* To do: support +33% */
		display: inline-block;
		padding: 1em 0;
		margin: 0;
		border: none;
		background: #eee;
		color: #333;

	}
	
	.col2 {
		
		width: 50%;

	}
	
	.col3 {
		
		width: 33.333%;

	}
	
	.col23 {
		
		width: 66.667%;
		
	}

	.col4 {
		
		width: 25%;

	}
	
</style>

<div class=row>
	
	<div>Auto</div>
	<div>Auto</div>
	<div class="col2">1/2</div>
	<div>Auto</div>
	<div>Auto</div>
	<div class="col23">2/3</div>
	<div>Auto</div>
	<div>Auto</div>
	<div class="col3">1/3</div>
	<div class="col23">2/3</div>
	<div>Auto</div>
	<div>Auto</div>
	<div>Auto</div>
	<div>Auto</div>
		
</div>

<br>

<div class=row>
	
	<div class="col23">2/3</div>
	<div>Auto</div>
	<div>Auto</div>
	<div class="col3">1/3</div>
	<div class="col23">2/3</div>
		
</div>

<script>

	function selectorMatches(el, selector) {
		
		return el.className.indexOf(selector) > -1;

	}
	
	// To do: equal height & vertical alignment

	function getStyle(el,styleProp) {
		if (el.currentStyle)
			var y = el.currentStyle[styleProp];
		else if (window.getComputedStyle)
			var y = document.defaultView.getComputedStyle(el,null).getPropertyValue(styleProp);
		return y;
	
	}

	function flexGridFallback() {
		
// 		var rows = Array.prototype.slice.call(document.querySelectorAll('.row')); // Node list to array
		var rows = document.querySelectorAll('.row'); // Node list to array
		var row_index = 0;
		
		for(;row_index < rows.length; row_index++) { // All rows
			
			var row = rows.item(row_index);
		
			var start_index = 0;
			var end_index = 0;
			var i = 1;
			for (;i <= row.children.length; i++) { // All columns in current row.
				
				var el = row.children[i];
				if (i === row.children.length || el.offsetLeft === row.offsetLeft)  { // If offset is the same as the row, the row has wrapped and its columns must take up 100% width

					end_index = i - 1;
					var number_auto_columns = 0;
					var space_taken = 0;
					
					var j;
					for (j = start_index; j <= end_index; j++) { // Cycle columns of the current auto-wrapped row
						
						if (selectorMatches(row.children[j], 'col')) {
							
							if (getStyle(row.children[j], 'width').indexOf('px') == -1) { // IE8, returning % instead of px
	
								space_taken = parseFloat(getStyle(row.children[j], 'width'));
							
							} else {
							
								space_taken = parseFloat(getStyle(row.children[j], 'width')) / parseFloat(getStyle(row, 'width'))*100;
							
							}
							
						} else {
							
							number_auto_columns++;
						
						}
						
					}
					
// 					console.log('Start: ' + start_index + ', End: ' + end_index + ', Auto columns: ' + number_auto_columns);
					
					var auto_column_width = (100 - space_taken) / number_auto_columns;
					
					for (j = start_index; j <= end_index; j++) { // Cycle columns of the current auto-wrapped row
						
						if (!selectorMatches(row.children[j], 'col')) {
							
							row.children[j].style.width = auto_column_width + '%';
							
						}
						
					}

					start_index = end_index + 1;

				}

			}
			
		}
		
	}
	
	flexGridFallback();

</script>
